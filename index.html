// ================================
// 1. ENHANCED ERROR HANDLING & VALIDATION
// ================================

// Improved form validation
function validateCustomerForm(formData) {
    const errors = [];
    
    if (!formData.name || formData.name.trim().length < 2) {
        errors.push('Customer name must be at least 2 characters');
    }
    
    if (formData.phone && !isValidMalaysianPhone(formData.phone)) {
        errors.push('Please enter a valid Malaysian phone number');
    }
    
    if (formData.email && !isValidEmail(formData.email)) {
        errors.push('Please enter a valid email address');
    }
    
    return errors;
}

function isValidMalaysianPhone(phone) {
    // Malaysian phone number patterns
    const patterns = [
        /^(\+?6?0)(1[0-46-9])\d{7,8}$/, // Mobile
        /^(\+?6?0)(3|4|5|6|7|8|9)\d{7,8}$/ // Landline
    ];
    return patterns.some(pattern => pattern.test(phone.replace(/[\s-]/g, '')));
}

function isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

// ================================
// 2. IMPROVED DATA PERSISTENCE
// ================================

// Enhanced storage with compression and versioning
class VegeOrderStorage {
    constructor() {
        this.version = '1.0.0';
        this.compressionEnabled = true;
    }
    
    async saveData(key, data) {
        try {
            const dataWithMeta = {
                version: this.version,
                timestamp: Date.now(),
                data: this.compressionEnabled ? this.compressData(data) : data,
                compressed: this.compressionEnabled
            };
            
            localStorage.setItem(key, JSON.stringify(dataWithMeta));
            return true;
        } catch (error) {
            console.error('Storage error:', error);
            this.handleStorageError(error);
            return false;
        }
    }
    
    async loadData(key) {
        try {
            const stored = localStorage.getItem(key);
            if (!stored) return null;
            
            const parsed = JSON.parse(stored);
            
            // Handle legacy data (no version)
            if (!parsed.version) {
                return parsed; // Old format
            }
            
            // Decompress if needed
            return parsed.compressed ? 
                this.decompressData(parsed.data) : 
                parsed.data;
        } catch (error) {
            console.error('Load error:', error);
            return null;
        }
    }
    
    compressData(data) {
        // Simple JSON compression (could use LZString library for better compression)
        return JSON.stringify(data);
    }
    
    decompressData(data) {
        return JSON.parse(data);
    }
    
    handleStorageError(error) {
        if (error.name === 'QuotaExceededError') {
            // Storage full - implement cleanup strategy
            this.cleanupOldData();
            showErrorMessage('Storage full. Cleaned up old data. Please try again.');
        }
    }
    
    cleanupOldData() {
        // Remove old data or implement data archiving
        const cutoffDate = Date.now() - (30 * 24 * 60 * 60 * 1000); // 30 days
        // Implementation depends on your data structure
    }
}

// ================================
// 3. ADVANCED SEARCH FUNCTIONALITY
// ================================

class SearchEngine {
    constructor() {
        this.searchIndex = new Map();
        this.initializeIndex();
    }
    
    initializeIndex() {
        // Build search index for better performance
        this.indexProducts();
        this.indexCustomers();
    }
    
    indexProducts() {
        products.forEach(product => {
            const searchableText = this.createSearchableText(product);
            this.searchIndex.set(`product_${product.id}`, {
                type: 'product',
                id: product.id,
                searchText: searchableText.toLowerCase(),
                data: product
            });
        });
    }
    
    indexCustomers() {
        customers.forEach(customer => {
            const searchableText = this.createSearchableText(customer);
            this.searchIndex.set(`customer_${customer.id}`, {
                type: 'customer',
                id: customer.id,
                searchText: searchableText.toLowerCase(),
                data: customer
            });
        });
    }
    
    createSearchableText(item) {
        return Object.values(item)
            .filter(value => typeof value === 'string')
            .join(' ');
    }
    
    search(query, type = null, options = {}) {
        const {
            fuzzy = true,
            limit = 50,
            sortBy = 'relevance'
        } = options;
        
        if (!query || query.length < 2) return [];
        
        const searchTerms = query.toLowerCase().split(' ').filter(term => term.length > 0);
        const results = [];
        
        for (const [key, item] of this.searchIndex) {
            if (type && item.type !== type) continue;
            
            const relevanceScore = this.calculateRelevance(item.searchText, searchTerms, fuzzy);
            if (relevanceScore > 0) {
                results.push({
                    ...item,
                    relevance: relevanceScore,
                    highlighted: this.highlightMatches(item.data.name || item.data.title, searchTerms)
                });
            }
        }
        
        // Sort by relevance
        results.sort((a, b) => b.relevance - a.relevance);
        
        return results.slice(0, limit);
    }
    
    calculateRelevance(text, searchTerms, fuzzy) {
        let score = 0;
        
        searchTerms.forEach(term => {
            if (text.includes(term)) {
                score += 10; // Exact match
            } else if (fuzzy && this.fuzzyMatch(text, term)) {
                score += 5; // Fuzzy match
            }
        });
        
        return score;
    }
    
    fuzzyMatch(text, term) {
        // Simple fuzzy matching - could be improved with Levenshtein distance
        if (term.length < 3) return false;
        
        for (let i = 0; i <= text.length - term.length; i++) {
            const substring = text.substr(i, term.length);
            const differences = this.countDifferences(substring, term);
            if (differences <= 1) return true; // Allow 1 character difference
        }
        return false;
    }
    
    countDifferences(str1, str2) {
        let differences = 0;
        for (let i = 0; i < str1.length; i++) {
            if (str1[i] !== str2[i]) differences++;
        }
        return differences;
    }
    
    highlightMatches(text, searchTerms) {
        let highlighted = text;
        searchTerms.forEach(term => {
            const regex = new RegExp(`(${term})`, 'gi');
            highlighted = highlighted.replace(regex, '<mark>$1</mark>');
        });
        return highlighted;
    }
}

// ================================
// 4. ANALYTICS & INSIGHTS
// ================================

class BusinessAnalytics {
    constructor() {
        this.analytics = {
            sales: [],
            customers: [],
            products: []
        };
    }
    
    generateDashboardData(dateRange = 30) {
        const endDate = new Date();
        const startDate = new Date(endDate.getTime() - (dateRange * 24 * 60 * 60 * 1000));
        
        return {
            salesTrend: this.getSalesTrend(startDate, endDate),
            topProducts: this.getTopProducts(startDate, endDate),
            topCustomers: this.getTopCustomers(startDate, endDate),
            categoryPerformance: this.getCategoryPerformance(startDate, endDate),
            insights: this.generateInsights(startDate, endDate)
        };
    }
    
    getSalesTrend(startDate, endDate) {
        const dailySales = new Map();
        
        orders.forEach(order => {
            const orderDate = new Date(order.createdAt);
            if (orderDate >= startDate && orderDate <= endDate) {
                const dateKey = orderDate.toISOString().split('T')[0];
                const currentSales = dailySales.get(dateKey) || 0;
                dailySales.set(dateKey, currentSales + order.total);
            }
        });
        
        // Fill missing dates with 0
        const result = [];
        for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
            const dateKey = d.toISOString().split('T')[0];
            result.push({
                date: dateKey,
                sales: dailySales.get(dateKey) || 0
            });
        }
        
        return result;
    }
    
    getTopProducts(startDate, endDate, limit = 10) {
        const productSales = new Map();
        
        orders.forEach(order => {
            const orderDate = new Date(order.createdAt);
            if (orderDate >= startDate && orderDate <= endDate) {
                order.items.forEach(item => {
                    const current = productSales.get(item.vegeId) || { 
                        name: item.vegeName, 
                        quantity: 0, 
                        revenue: 0,
                        orders: 0
                    };
                    
                    current.quantity += item.quantity;
                    current.revenue += item.quantity * item.price;
                    current.orders += 1;
                    
                    productSales.set(item.vegeId, current);
                });
            }
        });
        
        return Array.from(productSales.entries())
            .map(([id, data]) => ({ productId: id, ...data }))
            .sort((a, b) => b.revenue - a.revenue)
            .slice(0, limit);
    }
    
    getTopCustomers(startDate, endDate, limit = 10) {
        const customerData = new Map();
        
        orders.forEach(order => {
            const orderDate = new Date(order.createdAt);
            if (orderDate >= startDate && orderDate <= endDate) {
                const current = customerData.get(order.customerId) || {
                    customerId: order.customerId,
                    totalSpent: 0,
                    orderCount: 0,
                    lastOrderDate: null
                };
                
                current.totalSpent += order.total;
                current.orderCount += 1;
                current.lastOrderDate = orderDate;
                
                customerData.set(order.customerId, current);
            }
        });
        
        return Array.from(customerData.values())
            .sort((a, b) => b.totalSpent - a.totalSpent)
            .slice(0, limit)
            .map(data => {
                const customer = customers.find(c => c.id === data.customerId);
                return {
                    ...data,
                    customerName: customer ? customer.name : 'Unknown'
                };
            });
    }
    
    generateInsights(startDate, endDate) {
        const insights = [];
        
        // Sales growth insight
        const currentPeriodSales = this.getTotalSales(startDate, endDate);
        const previousPeriodStart = new Date(startDate.getTime() - (endDate.getTime() - startDate.getTime()));
        const previousPeriodSales = this.getTotalSales(previousPeriodStart, startDate);
        
        if (previousPeriodSales > 0) {
            const growth = ((currentPeriodSales - previousPeriodSales) / previousPeriodSales) * 100;
            insights.push({
                type: 'sales_growth',
                title: `Sales ${growth >= 0 ? 'Growth' : 'Decline'}`,
                value: `${Math.abs(growth).toFixed(1)}%`,
                trend: growth >= 0 ? 'up' : 'down',
                description: `Compared to previous period`
            });
        }
        
        // Most profitable day insight
        const dailyTotals = this.getSalesTrend(startDate, endDate);
        const bestDay = dailyTotals.reduce((max, day) => day.sales > max.sales ? day : max);
        insights.push({
            type: 'best_day',
            title: 'Best Sales Day',
            value: `RM ${bestDay.sales.toFixed(2)}`,
            description: `${new Date(bestDay.date).toLocaleDateString('en-MY')}`
        });
        
        return insights;
    }
    
    getTotalSales(startDate, endDate) {
        return orders
            .filter(order => {
                const orderDate = new Date(order.createdAt);
                return orderDate >= startDate && orderDate <= endDate;
            })
            .reduce((total, order) => total + order.total, 0);
    }
}

// ================================
// 5. NOTIFICATION SYSTEM
// ================================

class NotificationManager {
    constructor() {
        this.permission = 'default';
        this.init();
    }
    
    async init() {
        if ('Notification' in window) {
            this.permission = await Notification.requestPermission();
        }
        
        // Register service worker for push notifications
        if ('serviceWorker' in navigator) {
            try {
                const registration = await navigator.serviceWorker.register('/sw.js');
                console.log('SW registered:', registration);
            } catch (error) {
                console.log('SW registration failed:', error);
            }
        }
    }
    
    async showNotification(title, options = {}) {
        if (this.permission !== 'granted') {
            console.log('Notification permission not granted');
            return;
        }
        
        const defaultOptions = {
            icon: '/icon-192.png',
            badge: '/badge-72.png',
            vibrate: [200, 100, 200],
            data: { timestamp: Date.now() },
            requireInteraction: false
        };
        
        const notificationOptions = { ...defaultOptions, ...options };
        
        if ('serviceWorker' in navigator) {
            const registration = await navigator.serviceWorker.ready;
            registration.showNotification(title, notificationOptions);
        } else {
            new Notification(title, notificationOptions);
        }
    }
    
    orderStatusUpdate(orderId, status) {
        const titles = {
            pending: '⏳ Order Confirmed',
            completed: '✅ Order Ready'
        };
        
        const messages = {
            pending: 'Your order has been confirmed and is being prepared.',
            completed: 'Your order is ready for pickup!'
        };
        
        this.showNotification(titles[status], {
            body: messages[status],
            tag: `order-${orderId}`,
            data: { orderId, action: 'view_order' }
        });
    }
    
    lowStockAlert(productName, currentStock) {
        this.showNotification('📦 Low Stock Alert', {
            body: `${productName} is running low (${currentStock} remaining)`,
            tag: 'low-stock',
            requireInteraction: true
        });
    }
    
    dailySummary(salesData) {
        this.showNotification('📊 Daily Sales Summary', {
            body: `Today's sales: RM ${salesData.total.toFixed(2)} | ${salesData.orders} orders`,
            tag: 'daily-summary'
        });
    }
}

// ================================
// 6. OFFLINE SUPPORT
// ================================

class OfflineManager {
    constructor() {
        this.isOnline = navigator.onLine;
        this.syncQueue = [];
        this.init();
    }
    
    init() {
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.syncPendingData();
            this.showConnectionStatus('🌐 Back online! Syncing data...');
        });
        
        window.addEventListener('offline', () => {
            this.isOnline = false;
            this.showConnectionStatus('📴 Offline mode - changes will sync when back online');
        });
    }
    
    addToSyncQueue(action, data) {
        this.syncQueue.push({
            id: Date.now(),
            action,
            data,
            timestamp: new Date().toISOString()
        });
        
        if (this.isOnline) {
            this.syncPendingData();
        }
    }
    
    async syncPendingData() {
        if (this.syncQueue.length === 0) return;
        
        console.log(`Syncing ${this.syncQueue.length} pending changes...`);
        
        // Process sync queue
        const processed = [];
        for (const item of this.syncQueue) {
            try {
                await this.processSync(item);
                processed.push(item.id);
            } catch (error) {
                console.error('Sync failed for item:', item, error);
                // Keep in queue for retry
            }
        }
        
        // Remove successfully processed items
        this.syncQueue = this.syncQueue.filter(item => !processed.includes(item.id));
        
        if (processed.length > 0) {
            this.showConnectionStatus(`✅ Synced ${processed.length} changes`);
        }
    }
    
    async processSync(item) {
        // Implement actual sync logic based on action type
        switch (item.action) {
            case 'create_order':
                // Sync order to server
                break;
            case 'update_customer':
                // Sync customer update
                break;
            default:
                console.log('Unknown sync action:', item.action);
        }
    }
    
    showConnectionStatus(message) {
        showSuccessMessage(message);
    }
}

// ================================
// 7. INVENTORY MANAGEMENT
// ================================

class InventoryManager {
    constructor() {
        this.inventory = new Map();
        this.lowStockThreshold = 10;
        this.loadInventoryData();
    }
    
    loadInventoryData() {
        // Load inventory data from storage
        products.forEach(product => {
            this.inventory.set(product.id, {
                productId: product.id,
                currentStock: 100, // Default stock
                reserved: 0,
                lowStockThreshold: this.lowStockThreshold,
                unit: product.unit,
                costPrice: product.price * 0.7, // Assume 30% markup
                lastRestocked: new Date().toISOString()
            });
        });
    }
    
    updateStock(productId, quantity, type = 'sale') {
        const item = this.inventory.get(productId);
        if (!item) return false;
        
        switch (type) {
            case 'sale':
                item.currentStock -= quantity;
                break;
            case 'restock':
                item.currentStock += quantity;
                item.lastRestocked = new Date().toISOString();
                break;
            case 'reserve':
                item.reserved += quantity;
                break;
            case 'unreserve':
                item.reserved -= quantity;
                break;
        }
        
        // Check for low stock
        if (item.currentStock <= item.lowStockThreshold) {
            this.handleLowStock(productId);
        }
        
        this.saveInventoryData();
        return true;
    }
    
    handleLowStock(productId) {
        const product = products.find(p => p.id === productId);
        const stockItem = this.inventory.get(productId);
        
        if (product && stockItem) {
            // Show notification
            const notificationManager = new NotificationManager();
            notificationManager.lowStockAlert(product.name, stockItem.currentStock);
            
            // Add to low stock alerts
            console.log(`Low stock alert: ${product.name} - ${stockItem.currentStock} ${stockItem.unit} remaining`);
        }
    }
    
    getAvailableStock(productId) {
        const item = this.inventory.get(productId);
        return item ? item.currentStock - item.reserved : 0;
    }
    
    getLowStockItems() {
        const lowStockItems = [];
        
        for (const [productId, stockItem] of this.inventory) {
            if (stockItem.currentStock <= stockItem.lowStockThreshold) {
                const product = products.find(p => p.id === productId);
                if (product) {
                    lowStockItems.push({
                        ...product,
                        currentStock: stockItem.currentStock,
                        threshold: stockItem.lowStockThreshold
                    });
                }
            }
        }
        
        return lowStockItems;
    }
    
    saveInventoryData() {
        const storage = new VegeOrderStorage();
        storage.saveData('vegeorder_inventory', Array.from(this.inventory.entries()));
    }
}

// ================================
// 8. EXPORT IMPROVEMENTS
// ================================

class EnhancedExporter {
    constructor() {
        this.formats = ['excel', 'pdf', 'csv', 'json'];
    }
    
    async exportOrdersReport(dateRange, format = 'excel') {
        const orders = this.getOrdersInRange(dateRange);
        const reportData = this.generateReportData(orders);
        
        switch (format) {
            case 'excel':
                return this.exportToExcel(reportData);
            case 'pdf':
                return this.exportToPDF(reportData);
            case 'csv':
                return this.exportToCSV(reportData);
            case 'json':
                return this.exportToJSON(reportData);
            default:
                throw new Error(`Unsupported format: ${format}`);
        }
    }
    
    generateReportData(orders) {
        const analytics = new BusinessAnalytics();
        
        return {
            summary: {
                totalOrders: orders.length,
                totalRevenue: orders.reduce((sum, order) => sum + order.total, 0),
                averageOrderValue: orders.length > 0 ? 
                    orders.reduce((sum, order) => sum + order.total, 0) / orders.length : 0,
                dateRange: {
                    start: Math.min(...orders.map(o => new Date(o.createdAt))),
                    end: Math.max(...orders.map(o => new Date(o.createdAt)))
                }
            },
            orders: orders.map(order => ({
                ...order,
                customerName: this.getCustomerName(order.customerId),
                itemCount: order.items.length
            })),
            topProducts: analytics.getTopProducts(
                new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), 
                new Date()
            ),
            customerAnalytics: analytics.getTopCustomers(
                new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), 
                new Date()
            )
        };
    }
    
    getOrdersInRange(dateRange) {
        const { start, end } = dateRange;
        return orders.filter(order => {
            const orderDate = new Date(order.createdAt);
            return orderDate >= start && orderDate <= end;
        });
    }
    
    getCustomerName(customerId) {
        const customer = customers.find(c => c.id === customerId);
        return customer ? customer.name : 'Unknown Customer';
    }
}

// ================================
// USAGE EXAMPLES
// ================================

// Initialize enhanced systems
const searchEngine = new SearchEngine();
const analytics = new BusinessAnalytics();
const notificationManager = new NotificationManager();
const offlineManager = new OfflineManager();
const inventoryManager = new InventoryManager();
const storage = new VegeOrderStorage();

// Example: Enhanced search
function enhancedProductSearch(query) {
    const results = searchEngine.search(query, 'product', {
        fuzzy: true,
        limit: 20,
        sortBy: 'relevance'
    });
    
    // Render results with highlighting
    const html = results.map(result => `
        <div class="search-result">
            <h4>${result.highlighted}</h4>
            <p>Category: ${result.data.category}</p>
            <p>Price: RM ${result.data.price}</p>
        </div>
    `).join('');
    
    return html;
}

// Example: Analytics dashboard
function renderAnalyticsDashboard() {
    const dashboardData = analytics.generateDashboardData(30);
    
    // Render charts and insights
    console.log('Dashboard Data:', dashboardData);
    
    // Display insights
    dashboardData.insights.forEach(insight => {
        console.log(`${insight.title}: ${insight.value} - ${insight.description}`);
    });
}

// Example: Order status notification
function updateOrderStatus(orderId, newStatus) {
    // Update order status
    const order = orders.find(o => o.id === orderId);
    if (order) {
        order.status = newStatus;
        order.updatedAt = new Date().toISOString();
        
        // Send notification
        notificationManager.orderStatusUpdate(orderId, newStatus);
        
        // Update inventory if completed
        if (newStatus === 'completed') {
            order.items.forEach(item => {
                inventoryManager.updateStock(item.vegeId, item.quantity, 'sale');
            });
        }
        
        // Save changes
        storage.saveData('vegeorder_orders', orders);
        
        // Add to offline sync queue
        offlineManager.addToSyncQueue('update_order_status', {
            orderId,
            status: newStatus,
            timestamp: order.updatedAt
        });
    }
}
